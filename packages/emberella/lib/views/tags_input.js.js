// Generated by CoffeeScript 1.7.1
(function() {
  var DEFAULT_DELIMITER, ESCAPE_REG_EXP, ESCAPE_REPLACEMENT, Emberella, get, jQuery, set, setProperties, typeOf,
    __hasProp = {}.hasOwnProperty;

  Emberella = window.Emberella;

  jQuery = window.jQuery;

  get = Ember.get;

  set = Ember.set;

  setProperties = Ember.setProperties;

  typeOf = Ember.typeOf;

  DEFAULT_DELIMITER = ',';

  ESCAPE_REG_EXP = /[\-\[\]{}()*+?.,\\\^$|#\s]/g;

  ESCAPE_REPLACEMENT = '\\$&';


  /*
    The aim of `Emberella.TagsInput` is to present users with an easy to use tag
    input and creation experience that approaches the quality of a desktop
    interaction pattern. Rather than simply instructing users to "split tags
    with a comma" in a plain text input, the `Emberella.TagsInput` creates
    distinctive listing views for each tag. Tags can also be used to represent
    complex objects. Thus this tags input view may be used to display an array of
    words or establish complex relationships between objects through text entry.
  
    To work with this input control, bind the `content` property to data
    represented as an array of strings or objects.
  
    With styling, the `Emberella.TagsInput` can nearly mimic the experience of
    entering email addresses in the "To:" field of Mac OS X Mail.
  
    TODO: Multi-select
    TODO: drag and drop rearrangement
    TODO: Improved handling for duplicate tags
    TODO: Code cleanup and refactor to allow tag UI to integrate into other
          views, perhaps as a mixin
    TODO: Multiple cursors to allow invalid tags to remain editable in place
  
    @class TagsInput
    @namespace Emberella
    @extends Ember.ContainerView
    @uses Ember.StyleBindingsMixin
    @uses Emberella.FocusableMixin
    @uses Emberella.KeyboardControlMixin
   */

  Emberella.TagsInput = Ember.ContainerView.extend(Ember.StyleBindingsMixin, Emberella.FocusableMixin, Emberella.KeyboardControlMixin, {
    _value: '',
    _cursor: 0,
    init: function() {
      var content, ret, value;
      ret = this._super();
      value = get(this, 'value');
      content = get(this, 'content');
      if (!Ember.isArray(content)) {
        set(this, 'content', Ember.A());
      }
      set(this, '_value', value);
      if (value != null) {
        this.capture(value);
      }
      this._setupContent();
      this._renderList();
      return ret;
    },

    /*
      Declares this view is a tags input view.
    
      @property isTagsInput
      @type Boolean
      @default true
      @final
     */
    isTagsInput: true,

    /*
      Add the 'emberella-tags-input' class to the tag input element. Use this
      class to style your tag input.
    
      @property classNames
      @type Array
      @default ['emberella-tags-input']
     */
    classNames: ['emberella-tags-input'],
    classNameBindings: ['disabled'],

    /*
      Binds the width and height styles to the properties of the same name.
    
      @property styleBindings
      @type Array
      @default ['width', 'height']
     */
    styleBindings: ['width', 'height'],

    /*
      Disables tag input when true.
    
      @property disabled
      @type Boolean
      @default false
     */
    disabled: false,

    /*
      The view class to use for each item listing. The default
      `Emberella.TagItemView` is already designed to provide a familiar
      interaction pattern to users. But, of course, you are welcome to
      override this property and provide your own custom tag listing class with
      adapted or entirely custom behavior.
    
      @property itemViewClass
      @type Ember.View
      @default Emberella.TagItemView
     */
    itemViewClass: 'Emberella.TagItemView',

    /*
      The view class that allows users to enter new tags. The default
      `Emberella.TagItemInput` is a flexible text field designed to allow input
      directly at the beginning, middle, or end of a list of tags. You can
      override this property to install new or custom behavior to the
      input field.
    
      @property inputViewClass
      @type Ember.View
      @default Emberella.TagItemInput
     */
    inputViewClass: 'Emberella.TagItemInput',

    /*
      The content of this tags input. The content may be an array of strings
      or objects.
    
      @property content
      @type Array
      @default null
     */
    content: null,

    /*
      A string representation of the input's `content`. If this view manages an
      array of strings (e.g. `['Ember', 'Javascript', 'Frontend', 'Code']`), then
      the value property can be seeded with a string value and will be updated
      as strings are added to and removed from the `content` array.
    
      If a tag instance expects to manage objects, the value will not be
      automatically updated as the content changes.
    
      In any case, updating the `value` will not cause any automatic updates to
      the `content` array.
    
      @property value
      @type String
      @default ''
     */
    value: '',

    /*
      A delimiter to use when splitting or assembling tag values. This property
      can be set to a string or an array of strings and regular expressions.
    
      If the delimiter property is a string, it will be split into individual
      characters and each character will be used as a delimiter.
    
      @example
        // semi-colons (';'), colons (':'), and spaces (' ') will break string
        // values into tags.
        //
        // 'one; two: three four' -> ['one', 'two', 'three', 'four']
        this.set('delimiter', ';: ');
    
      If the delimiter property is an array of strings and regular expressions,
      then each member of the array will be used to split strings into tags.
    
      @example
        // commas(','), semi-colons (';'), and numbers (0-9) will break string
        // values into tags.
        //
        // 'one1 two;three,four' -> ['one', 'two', 'three', 'four']
        this.set('delimiter', [',', ';', /\d/]);
    
      If no delimiter is specified, the tags input will fallback to a comma (,)
      as the default delimiter.
    
      @property delimiter
      @type {String|Array}
      @default ','
     */
    delimiter: DEFAULT_DELIMITER,

    /*
      Prevent focus with TAB key.
    
      @property tabindex
      @type Integer
      @default -1
     */
    tabindex: -1,

    /*
      A width style for the tag input view.
    
      @property width
      @type {Integer|String}
      @default 'auto'
     */
    width: 'auto',

    /*
      A height style for the tag input view.
    
      @property height
      @type {Integer|String}
      @default 'auto'
     */
    height: 'auto',

    /*
      A placeholder to display when the input has no content.
    
      @property placeholder
      @type String
      @default ''
     */
    placeholder: '',

    /*
      A string to display as the 'delete' button in the default tag listing
      template.
    
      @property deleteCharacter
      @type String
      @default 'x'
     */
    deleteCharacter: 'x',

    /*
      A string to display as the "title" attribute of the "delete" button in the
      default tag listing template.
    
      @property deleteTitle
      @type String
      @default 'Remove tag'
     */
    deleteTitle: 'Remove tag',

    /*
      Specifies if a tag should be created automatically when the tag input view
      instance loses focus.
    
      @property tagOnFocusOut
      @type Boolean
      @default true
     */
    tagOnFocusOut: true,

    /*
      The "get path" to follow to find a string to display in each tag listing.
    
      For example, if each item in this view's content array is an object
      structured like `{id: 1, label: 'Ember'}` and the `contentPath` is "label",
      then the tag listing for the sample item would appear with the word 'Ember'
      in the browser (i.e. the value of Ember.get(content, 'label')).
    
      If the `contentPath` is an empty string, the `content` property is expected
      to contain an array of strings.
    
      @property contentPath
      @type String
      @default ''
     */
    contentPath: '',

    /*
      A collection of fuctions to use for applying special classes to each tag
      listing.
    
      Set the `stylist` property to an object where each key represents a
      class name to add to a tag listing view and each value is a function that
      returns a truthy value when key should be added as a class name. This
      allows tags with special meaning to be styled differently as needed.
    
      @example
        // Adds the class 'is-ember' to any tag listing view with a label
        // of 'ember'.
        this.set('stylist', {
          'is-ember': function (content) {
            return (Ember.get(content, 'label').toLowerCase() === 'ember');
          }
        });
    
      Each stylist function is called in the context of its tag listing
      view instance.
    
      @property stylist
      @type Object
      @default null
     */
    stylist: null,

    /*
      The default template for each tag item listing. Set the `template` property
      to inject a custom template for tag listing views.
    
      @property defaultTemplate
      @type Ember.Handlebars
      @final
     */
    defaultTemplate: Ember.Handlebars.compile(['<span class="emberella-tag-item-content">{{view.displayContent}}</span>', '{{#unless view.disabled}}', '{{#if view.deleteCharacter}}', '<a href="#" {{bind-attr title="view.deleteTitle"}} {{action "removeSelf" target=view bubbles=false}}>{{view.deleteCharacter}}</a>', '{{/if}}', '{{/unless}}'].join(' ')),

    /*
      The primary delimiter is the first string or number in the `delimiter`
      property. If none of the delimiters is a string or number, a plain comma
      (',') will be used instead.
    
      The `_primary_delimiter` is used when converting an array of strings to a
      string value.
    
      @private
      @property _primary_delimiter
      @type String
      @readOnly
     */
    _primary_delimiter: Ember.computed(function() {
      var delimiter, ret;
      delimiter = get(this, 'delimiter');
      if (typeOf(delimiter) === 'string' || typeOf(delimiter) === 'number') {
        delimiter = delimiter + '';
        ret = get(delimiter, '0');
      } else if (Ember.isArray(delimiter)) {
        ret = delimiter.find(function(d) {
          return typeOf(d) === 'string' || typeOf(d) === 'number';
        });
      }
      return (ret || DEFAULT_DELIMITER) + '';
    }).property('delimiter', 'delimiter.length').volatile().readOnly(),

    /*
      This computed property converts the public `delimiter` setting into a
      string that can be transformed into a regular expression object.
    
      @private
      @property _delimiter
      @type String
      @readOnly
     */
    _delimiter: Ember.computed(function() {
      var delimiter;
      delimiter = get(this, 'delimiter') || DEFAULT_DELIMITER;
      if (typeOf(delimiter) === 'string' || typeOf(delimiter) === 'number') {
        delimiter = (delimiter + '').split('');
      }
      if (Ember.isArray(delimiter)) {
        delimiter = Ember.A(delimiter.slice()).map((function(_this) {
          return function(item) {
            if (typeOf(item) === 'string' || typeOf(item) === 'number') {
              return _this._escapeRegExpString(item.toString());
            } else if (typeOf(item) === 'regexp') {
              return item.toString().split('/').slice(1, -1).join('/');
            }
            return null;
          };
        })(this)).compact();
      }
      if (!Ember.isArray(delimiter)) {
        delimiter = Ember.A(this._escapeRegExpString(DEFAULT_DELIMITER));
      }
      return delimiter.join('|');
    }).property('delimiter', 'delimiter.length').readOnly(),

    /*
      Returns a regular expression object that can be used to split and
      manipulate strings and input values based on the specified `delimiter`
      property.
    
      @private
      @property _delimiter_pattern
      @type RegExp
      @readOnly
     */
    _delimiter_pattern: Ember.computed(function() {
      return new RegExp(get(this, '_delimiter'), 'g');
    }).volatile().readOnly(),

    /*
      The current cursor position (i.e. index of the input view among this tag
      input's child views).
    
      The computed property ensures the cursor position does not exceed the
      length of the tag input's content.
    
      @property cursor
      @type Integer
     */
    cursor: Ember.computed(function(key, value) {
      var contentLength, result;
      if (arguments.length === 1) {
        result = get(this, '_cursor');
        contentLength = get(this, 'content.length');
        if (result == null) {
          return contentLength;
        }
        result = Math.max(0, Math.min(parseInt(result, 10), contentLength));
        return result;
      } else {
        return set(this, '_cursor', value);
      }
    }).volatile(),

    /*
      Insert a single new tag value into the `content` array at a given index.
      If no index is specified, the `cursor` position will be used instead.
    
      Before a tag is allowed into the `content` array, the `willAddValue()`
      method will be called. Tag addition will be aborted if `willAddValue()`
      returns `false`.
    
      After a tag is inserted into the `content`, the `didAddValue` event
      will be triggered. Override `didAddValue()` or add an event handler to
      inject custom logic for handling newly created tags.
    
      @method addTag
      @param {String|Object} value A value to insert into the content array
      @param Integer idx The position/index at which to insert the new value
      @chainable
     */
    addTag: function(value, idx) {
      var method, type;
      if (value == null) {
        value = '';
      }
      if (idx == null) {
        idx = get(this, 'cursor');
      }
      type = typeOf(value);
      method = '_' + Ember.String.camelize(['prepare', type, 'tag'].join('-'));
      if (typeOf(this[method]) !== 'function') {
        throw new TypeError("Attempting to add tag of an unsupported type " + type);
      }
      if (!((value = this[method](value)) === false || this._willAddValue(value, idx) === false)) {
        this.insertContent(value, idx);
        this._didAddValue(value, idx);
      }
      return this;
    },

    /*
      Add an array of tags.
    
      @method addTags
      @param Array values Array of tags to add
      @chainable
     */
    addTags: function(values) {
      var cursor, i, value, _i, _len;
      if (values == null) {
        values = Ember.A();
      }
      this.beginPropertyChanges();
      cursor = get(this, 'cursor');
      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
        value = values[i];
        this.addTag(value, cursor + i);
      }
      this.endPropertyChanges();
      return this;
    },

    /*
      Convert the provided string (or current input value) into an array of new
      tags and add them to the `content`.
    
      @method capture
      @param String value A value to capture (default: `inputView.value`)
      @param Boolean retainFocus The input should regain focus after render
      @chainable
     */
    capture: function(value, retainFocus) {
      var inputValue, len, values;
      if (retainFocus == null) {
        retainFocus = this.isFocused();
      }
      inputValue = get(this, 'inputView.value');
      if (typeOf(value) !== 'string') {
        value = inputValue;
      }
      values = this.tagify(value);
      len = get(this, 'content.length');
      this.addTags(values);
      if (len !== get(this, 'content.length')) {
        Ember.run.schedule('afterRender', this, function() {
          if (value === inputValue) {
            this.reset();
          }
          return this.refocus(retainFocus);
        });
      }
      return this;
    },

    /*
      Determine if the provided string value is already represented as a tag in
      this input view.
    
      Exact matches will always return true. If no exact match is found, this
      method will use the `isEqual()` method to search for tag content that is
      equivalent to the provided value.
    
      @method contains
      @param String value A string to search for
      @return Boolean
     */
    contains: function(value) {
      var content, match;
      content = get(this, 'content');
      if (content == null) {
        return false;
      }
      if (content.contains(value)) {
        return true;
      }
      match = content.find((function(_this) {
        return function(obj) {
          return _this.isEqual(value, obj);
        };
      })(this));
      return !!match;
    },

    /*
      Compare two tag values (typically a string and an object) to
      determine equivalency.
    
      For example, the string `"foo"` may be equivalent to the object
      `{"label": "foo"}` when managing a list of tags.
    
      Override with your own method to inject a custom comparison for strings
      and tag objects.
    
      @method isEqual
      @param {String|Object} value The needle
      @param Object tag An object from the content array
      @return Boolean
     */
    isEqual: function(value, tag) {
      var contentPath, contentValue;
      contentPath = get(this, 'contentPath');
      value = get(value, contentPath) || value;
      contentValue = get(tag, contentPath) || '';
      return (value.toLowerCase != null) && (contentValue.toLowerCase != null) && value.toLowerCase() === contentValue.toLowerCase();
    },

    /*
      Place the input view before the specified view instance.
    
      @method cursorBefore
      @param Ember.View view The child view to place the cursor before
      @chainable
     */
    cursorBefore: function(view) {
      return this.moveCursor(view, -1);
    },

    /*
      Place the input view after the specified view instance.
    
      @method cursorAfter
      @param Ember.View view The child view to place the cursor after
      @chainable
     */
    cursorAfter: function(view) {
      return this.moveCursor(view);
    },

    /*
      Place the input view some distance after the specified view instance.
    
      Use a negative number to move the input to a lower index.
    
      @method moveCursor
      @param Ember.View view The child view to move the cursor from
      @param Integer shift How far to move focus
      @chainable
     */
    moveCursor: function(view, shift) {
      var childViews, cursor, idx;
      if (shift == null) {
        shift = 1;
      }
      if (view == null) {
        return this;
      }
      cursor = get(this, 'cursor');
      childViews = get(this, 'childViews');
      idx = childViews.indexOf(view);
      if (idx > cursor) {
        shift = shift - 1;
      }
      set(this, 'cursor', idx + shift);
      this.refocus(true, shift < 0);
      return this;
    },

    /*
      Move document focus to the child view at the provided index.
    
      @method focusOn
      @param Integer idx The index of the child to gain focus
      @chainable
     */
    focusOn: function(idx) {
      var childViews, viewToFocus;
      childViews = get(this, 'childViews');
      viewToFocus = childViews.objectAt(idx);
      if (viewToFocus == null) {
        viewToFocus = get(childViews, 'lastObject');
      }
      return this.moveFocus(viewToFocus, 0);
    },

    /*
      Move focus to the view before the provided child view.
    
      @method focusBefore
      @param Ember.View view The child view to focus before
      @chainable
     */
    focusBefore: function(view) {
      return this.moveFocus(view, -1);
    },

    /*
      Move focus to the view after the provided child view.
    
      @method focusAfter
      @param Ember.View view The child view to focus after
      @chainable
     */
    focusAfter: function(view) {
      return this.moveFocus(view);
    },

    /*
      Place focus a number of sibling views after the provided view.
    
      Use a negative number to move the focus to a sibling with a lower index.
    
      @method moveFocus
      @param Ember.View view The child view to move focus from
      @param Integer shift How far to move focus
      @chainable
     */
    moveFocus: function(view, shift) {
      var childViews, firstView, idx, lastView, viewToFocus, _ref;
      if (shift == null) {
        shift = 1;
      }
      if (view == null) {
        return this;
      }
      childViews = get(this, 'childViews');
      idx = childViews.indexOf(view);
      firstView = get(childViews, 'firstObject');
      lastView = get(childViews, 'lastObject');
      viewToFocus = childViews.objectAt(Math.max(0, Math.min(childViews.length - 1, idx + shift)));
      if (viewToFocus == null) {
        viewToFocus = lastView;
      }
      if (this.isInputView(viewToFocus)) {
        if (viewToFocus === firstView) {
          viewToFocus = viewToFocus;
        } else if (viewToFocus === lastView) {
          viewToFocus = (_ref = childViews.objectAt(childViews.length - 1)) != null ? _ref : viewToFocus;
        } else {
          idx = childViews.indexOf(viewToFocus);
          viewToFocus = childViews.objectAt(idx + (shift / Math.abs(shift)));
        }
      }
      get(viewToFocus, 'element').focus();
      return this;
    },

    /*
      Focus on input view and place selection in the expected position.
    
      @method focus
      @param {Object|Event} e A focus event
      @param Boolean beginning Move selection to the start of the input value
      @chainable
     */
    focus: function(e, beginning) {
      var element, inputView, selection;
      if (beginning == null) {
        beginning = false;
      }
      if (!(((inputView = get(this, 'inputView')) != null) && get(inputView, 'state') === 'inDOM')) {
        return this;
      }
      element = get(inputView, 'element');
      if (element != null) {
        element.focus();
      }
      selection = beginning ? 0 : get(inputView, 'value.length');
      element.selectionStart = selection;
      element.selectionEnd = selection;
      return this;
    },

    /*
      Convenience method for obtaining the view class for text input.
    
      @method getInputViewClass
      @return Ember.View
     */
    getInputViewClass: function() {
      return this._getViewClass('inputViewClass');
    },

    /*
      Convenience method for obtaining the view class for tag listings.
    
      @method getItemViewClass
      @return Ember.View
     */
    getItemViewClass: function() {
      return this._getViewClass('itemViewClass');
    },

    /*
      Determine if the tags input view or any of its child views have focus.
    
      @method isFocused
      @return Boolean
     */
    isFocused: function() {
      var focused;
      focused = this.find(function(childView) {
        return get(childView, 'hasFocus');
      });
      return !!focused;
    },

    /*
      Inject a new tag into the content array.
    
      @method insertContent
      @param {String|Object} value A tag to insert
      @param Integer idx The index at which to insert the new tag
      @chainable
     */
    insertContent: function(value, idx) {
      get(this, 'content').insertAt(idx, value);
      return this;
    },

    /*
      Check if the provided view is an instance of the input view class.
    
      @method isInputView
      @param Mixed view A value to check
      @return Boolean
     */
    isInputView: function(view) {
      return !!(view instanceof this.getInputViewClass());
    },

    /*
      Check if the provided view is an instance of the item view class.
    
      @method isItemView
      @param Mixed view A value to check
      @return Boolean
     */
    isItemView: function(view) {
      return !!(view instanceof this.getItemViewClass());
    },

    /*
      Determine if the text field's selection cursor is positioned entirely
      before the input's value.
    
      @method isSelectionAtStart
      @return Boolean
     */
    isSelectionAtStart: function() {
      var element, inputView;
      if (!(((inputView = get(this, 'inputView')) != null) && get(inputView, 'state') === 'inDOM')) {
        return this;
      }
      element = get(inputView, 'element');
      return !!(element.selectionStart === 0 && element.selectionEnd === 0);
    },

    /*
      Determine if the text field's selection cursor is positioned entirely
      after the input's value.
    
      @method isSelectionAtEnd
      @return Boolean
     */
    isSelectionAtEnd: function() {
      var element, inputView, len;
      if (!(((inputView = get(this, 'inputView')) != null) && get(inputView, 'state') === 'inDOM')) {
        return this;
      }
      element = get(inputView, 'element');
      len = get(inputView, 'value.length');
      return !!(element.selectionStart === len && element.selectionEnd === len);
    },

    /*
      Determine if the `content` for this input instance is expected to contain
      an array of strings (not objects).
    
      @method isStringContent
      @return Boolean
     */
    isStringContent: function() {
      return get(this, 'contentPath') === '';
    },

    /*
      Place focus on the input view when it's ready.
    
      @method refocus
      @param Boolean force Send `true` to ensure focus moves to the input view
      @param Boolean beginning Move selection to the start of the input value
     */
    refocus: function(force, beginning) {
      var inputView;
      inputView = get(this, 'inputView');
      if (!(force || this.isFocused())) {
        return;
      }
      if (get(inputView, 'state') === 'inDOM') {
        this.focus({}, beginning);
      } else {
        Ember.run.schedule('afterRender', this, function() {
          if (force || this.isFocused()) {
            return this.focus({}, beginning);
          }
        });
      }
    },

    /*
      Remove the provided value from the tag input's `content`.
    
      @method removeTag
      @param {String|Object} value The value to remove
      @chainable
     */
    removeTag: function(value) {
      var content, idx;
      if (value == null) {
        return this;
      }
      content = get(this, 'content');
      idx = content.indexOf(value);
      if (idx < 0 || this.willRemoveValue(value) === false) {
        return this;
      }
      content.removeObject(value);
      set(this, 'cursor', idx);
      this._didRemoveValue(value);
      return this;
    },

    /*
      Empty the value of the input view.
    
      @method reset
      @chainable
     */
    reset: function() {
      var inputView;
      if ((inputView = get(this, 'inputView')) == null) {
        return this;
      }
      set(inputView, 'value', '');
      return this;
    },

    /*
      Convert an array into a string joined by the primary delimiter.
    
      @method stringify
      @param Array arr An array to join into a string
      @return String
     */
    stringify: function(arr) {
      if (arr == null) {
        arr = get(this, 'content');
      }
      return this._arrayToString(arr);
    },

    /*
      Swap the provided string with the provided object in the `content` array.
    
      User entry can only be captured as a string. Therefore, you may need to
      use a given string to lookup or retrive an object. Once the desired object
      is prepared or retrieved, then it can be transplanted into the `content`
      array with `swap()`.
    
      @method swap
      @param String str A string to swap out
      @param Object obj An object to put in its place
      @chainable
     */
    swap: function(str, obj) {
      return this._swap(str, obj, this.isFocused());
    },

    /*
      Called during the input capture process to convert a user-provided string
      value into an array of strings.
    
      @method tagify
      @param String value A string to process into tags
      @return Array
     */
    tagify: function(value) {
      return this._splitStringByDelimiter(value);
    },

    /*
      Update the `value` property with the stringified `content` array.
    
      @method updateValue
      @chainable
     */
    updateValue: function() {
      if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {
        return this;
      }
      set(this, 'value', this.stringify());
      return this;
    },

    /*
      A pre-insertion check for a newly added string.
    
      Override this method to add custom tag validation. If a string should not
      be added, return `false`.
    
      @method willAddValue
      @param {String|Object} value A processed (delimiter split) value to add
      @param Integer idx The index at which to insert the new value
     */
    willAddValue: Ember.K,

    /*
      Override this method to inject custom behavior prior to a tag's removal.
    
      Return `false` to prevent the tag's removal.
    
      @method willRemoveValue
      @param {String|Object} value A tag being removed
     */
    willRemoveValue: Ember.K,

    /*
      Override this method to inject custom tag creation/retrieval logic into
      your tag input view. Once the tag is ready, add it to the listing by
      calling `swap(value, tag)` (where `tag` is the created/retrieved value).
    
      @event didAddValue
      @param {String|Object} value A processed (delimiter split) value to add
      @param Integer idx The index at which to insert the new value
     */
    didAddValue: Ember.K,

    /*
      Override this method to inject custom delete logic for tags that were just
      successfully removed from the content array.
    
      @event didRemoveValue
      @param {String|Object} value A tag being removed
     */
    didRemoveValue: Ember.K,

    /*
      Adjust cursor value after entry into the DOM.
    
      @event didInsertElement
     */
    didInsertElement: function() {
      this._super();
      return set(this, 'cursor', get(this, 'content.length'));
    },

    /*
      Respond to a click event on the view element. The tags input will try to
      position the input view near the position where the click occurred.
    
      @event click
      @param Event e The jQuery click event
     */
    click: function(e) {
      var idx, nearest, posX, posY;
      if (get(this, 'disabled') || e.target !== get(this, 'element')) {
        return;
      }
      posX = e.pageX;
      posY = e.pageY;
      nearest = this.find(function(childView) {
        var height, jQ, position, space;
        jQ = childView.$();
        if (jQ == null) {
          return false;
        }
        position = jQ.offset();
        height = jQ.outerHeight(true);
        space = jQ.outerWidth(true) - jQ.width();
        return !!((position.left > (posX - space) && (position.top + height) > posY) || position.top > posY);
      });
      idx = this.indexOf(nearest);
      if (idx > get(this, 'cursor')) {
        idx = idx - 1;
      }
      set(this, 'cursor', nearest ? idx : get(this, 'content.length'));
      return this.refocus(true);
    },

    /*
      Respond to the enter/return key while focus is on the input view.
    
      @event enterPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    enterPressed: function(e, alt, ctrl, meta, shift) {
      if (alt || ctrl || meta || shift) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      return this.capture();
    },

    /*
      Respond to the backspace key while focus is on the input view.
    
      @event backspacePressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    backspacePressed: function(e, alt, ctrl, meta, shift) {
      var inputView;
      if (alt || ctrl || meta || shift || !this.isSelectionAtStart() || !(inputView = get(this, 'inputView'))) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      return this.focusBefore(inputView);
    },

    /*
      Respond to the "forward" delete key while focus is on the input view.
    
      @event deletePressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    deletePressed: function(e, alt, ctrl, meta, shift) {
      var inputView;
      if (alt || ctrl || meta || shift || !this.isSelectionAtEnd() || !(inputView = get(this, 'inputView'))) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      return this.focusAfter(inputView);
    },

    /*
      Respond to the right arrow key while focus is on the input view.
    
      @event rightArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    rightArrowPressed: function(e, alt, ctrl, meta, shift) {
      var inputView, len;
      if (alt || ctrl || meta || !this.isSelectionAtEnd() || !(inputView = get(this, 'inputView'))) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      if (shift) {
        return this.focusAfter(inputView);
      } else {
        len = get(this, 'content.length');
        this.capture();
        if (len === get(this, 'content.length')) {
          return this.cursorAfter(inputView);
        }
      }
    },

    /*
      Respond to the left arrow key while focus is on the input view.
    
      @event leftArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    leftArrowPressed: function(e, alt, ctrl, meta, shift) {
      var inputView;
      if (alt || ctrl || meta || !this.isSelectionAtStart() || !(inputView = get(this, 'inputView'))) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      if (shift) {
        return this.focusBefore(inputView);
      } else {
        return this.cursorBefore(inputView);
      }
    },

    /*
      Respond to the up arrow key while focus is on the input view.
    
      @event upArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    upArrowPressed: function(e, alt, ctrl, meta, shift) {
      var inputView;
      if (alt || ctrl || meta || !(inputView = get(this, 'inputView')) || (get(inputView, 'value') !== '')) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      return this.cursorBefore(get(this, 'childViews.firstObject'));
    },

    /*
      Respond to the down arrow key while focus is on the input view.
    
      @event downArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
     */
    downArrowPressed: function(e, alt, ctrl, meta, shift) {
      var inputView;
      if (alt || ctrl || meta || !(inputView = get(this, 'inputView')) || (get(inputView, 'value') !== '')) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      return this.cursorAfter(get(this, 'childViews.lastObject'));
    },

    /*
      Watches for changes in the input's value and automatically captures tags
      if a delimiter match is found within the value.
    
      @method didInputValueChange
      @chainable
     */
    didInputValueChange: Ember.observer(function() {
      var delimiter, inputView, pattern, regexString, value;
      inputView = get(this, 'inputView');
      value = get(inputView, 'value');
      delimiter = get(this, '_delimiter_pattern');
      regexString = delimiter.toString().split('/').slice(1, -1).join('/');
      regexString = ['.+(', regexString, ')$'].join('');
      pattern = new RegExp(regexString, 'g');
      if (delimiter.test(value) && (pattern.test(value) || inputView._didPaste)) {
        this.capture();
      }
      inputView._didPaste = false;
      return this;
    }, 'inputView.value'),

    /*
      @private
    
      Updates child view rendering when the cursor position changes.
    
      @method _cursorDidChange
     */
    _cursorDidChange: Ember.observer(function() {
      if (get(this, 'childViews.length')) {
        return this._updateCursorLocation();
      } else {
        return this._updateChildViews();
      }
    }, 'cursor'),

    /*
      @private
    
      Update `content` and `value` to account for a change to the `delimiter`.
    
      @method _delimiterDidChange
     */
    _delimiterDidChange: Ember.observer(function() {
      var content;
      if (!this.isStringContent()) {
        return;
      }
      content = this._arrayToString(get(this, 'content'));
      this._clearContent();
      this.capture(content);
      return this.updateValue();
    }, 'delimiter'),
    _willAddValue: function(value, idx) {
      return this.willAddValue(value, idx);
    },
    _didAddValue: function(value, idx) {
      this.trigger('didAddValue', value, idx);
      return this;
    },
    _didRemoveValue: function(value) {
      this.trigger('didRemoveValue', value);
      return this;
    },

    /*
      @private
    
      Swaps the provided string with the provided object. If silent, then
      `content` is quietly swapped using `splice()` to update the array without
      causing the child views to be re-rendered (potentially causing focus to
      change), and the content of just a single tag listing is updated.
    
      If the tag is no longer in the `content` array, then nothing will happen.
    
      @method _swap
      @chainable
     */
    _swap: function(str, obj, silent) {
      var content, cursor, idx, itemView;
      content = get(this, 'content');
      idx = content.indexOf(str);
      cursor = get(this, 'cursor');
      if (idx >= 0) {
        if (silent) {
          content.splice(idx, 1, obj);
          itemView = get(this, 'childViews').objectAt(cursor <= idx ? idx + 1 : idx);
          if ((itemView != null) && get(itemView, 'content') === str) {
            set(itemView, 'content', obj);
          }
        } else {
          content.replace(idx, 1, [obj]);
        }
      }
      return this;
    },

    /*
      @private
    
      Attempts to retrieve a view class from a given property name.
    
      @method _getViewClass
      @return Ember.View
     */
    _getViewClass: function(property) {
      var viewClass;
      viewClass = get(this, property);
      if (typeOf(viewClass) === 'string') {
        viewClass = get(viewClass);
      }
      return viewClass;
    },

    /*
      @private
    
      Combines items in the `content` array to form a string value.
    
      @method _arrayToString
      @return String
     */
    _arrayToString: function(arr) {
      var contentPath, delimiter, result;
      if (arr == null) {
        arr = Ember.A();
      }
      if (!(Ember.Enumerable.detect(arr) || Ember.isArray(arr))) {
        throw new TypeError("Must pass Ember.Enumerable to Emberella.TagsInput#_arrayToString");
      }
      delimiter = get(this, '_primary_delimiter');
      contentPath = get(this, 'contentPath');
      if (Ember.isArray(arr)) {
        return result = arr.map(function(item) {
          var ret;
          if ((item != null) && (ret = get(item, contentPath))) {
            return ret;
          } else {
            return item;
          }
        }).compact().join(delimiter);
      }
    },

    /*
      @private
    
      Updates focus state as focus moves within the tags input view.
    
      @method _focusDidChange
     */
    _focusDidChange: Ember.observer(function() {
      return set(this, 'hasFocus', this.isFocused());
    }, '@each.hasFocus'),

    /*
      @private
    
      Perform actions when focus entirely exits the tags input view.
    
      @method _hasFocusDidChange
     */
    _hasFocusDidChange: Ember.observer(function() {
      if (!get(this, 'hasFocus')) {
        return Ember.run.later(this, function() {
          if (!(get(this, 'state') === 'inDOM' && !this.isFocused())) {
            return;
          }
          if (get(this, 'tagOnFocusOut')) {
            this.capture();
          }
          if (get(this, 'inputView.value') === '') {
            return set(this, 'cursor', get(this, 'childViews.length'));
          }
        }, 100);
      }
    }, 'hasFocus'),

    /*
      @private
    
      Render/update the tags listing and input views.
    
      @method _renderList
     */
    _renderList: function() {
      return this._updateChildViews();
    },

    /*
      @private
    
      Redraw all of the child views.
    
      @method _rerenderList
     */
    _rerenderList: function() {
      this.destroyAllChildren();
      return this._renderList();
    },

    /*
      @private
    
      Places an input view at the current `cursor` position.
    
      @method _insertInputView
     */
    _insertInputView: function() {
      var cursor, inputView;
      inputView = get(this, 'inputView');
      inputView = inputView && !get(inputView, 'isDestroyed') && !get(inputView, 'isDestroying') ? inputView : this._createInputView();
      cursor = get(this, 'cursor');
      this.insertAt(cursor, inputView);
    },

    /*
      @private
    
      Removes the input view from the DOM.
    
      @method _removeInputView
     */
    _removeInputView: function() {
      var e, inputView;
      inputView = get(this, 'inputView');
      inputView = inputView && !get(inputView, 'isDestroyed') && !get(inputView, 'isDestroying') ? inputView : this._createInputView();
      try {
        inputView.removeFromParent();
      } catch (_error) {
        e = _error;
      }
    },

    /*
      @private
    
      Creates a new input view instance.
    
      @method _createInputView
     */
    _createInputView: function() {
      var inputView;
      inputView = this.createChildView(this.getInputViewClass());
      set(this, 'inputView', inputView);
      return inputView;
    },

    /*
      @private
    
      Creates and updates tag listing views with the current `content` array.
    
      @method _updateChildViews
     */
    _updateChildViews: function() {
      var childView, childViews, childViewsLength, content, contentLength, i, itemViewClass, _i, _ref;
      if ((get(this, 'state') !== 'inDOM') || get(this, 'isDestroyed') || get(this, 'isDestroying')) {
        return;
      }
      this._removeInputView();
      childViews = this;
      childViewsLength = Math.max(0, get(this, 'length'));
      itemViewClass = this.getItemViewClass();
      content = get(this, 'content');
      contentLength = get(this, 'content.length');
      for (i = _i = 0, _ref = Math.max(childViewsLength, contentLength); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        childView = this.objectAt(i);
        if (i < contentLength) {
          if (!(childView instanceof itemViewClass)) {
            childView = this.createChildView(itemViewClass);
            this.insertAt(i, childView);
          }
          setProperties(childView, {
            'content': content[i],
            'index': i
          });
        } else {
          if (this.isItemView(childView)) {
            if (childView != null) {
              childView.removeFromParent();
            }
          }
        }
      }
      this._insertInputView();
    },

    /*
      @private
    
      Moves the input view without redrawing all childViews.
    
      @method _updateCursorLocation
     */
    _updateCursorLocation: function() {
      this._removeInputView();
      return this._insertInputView();
    },

    /*
      @private
    
      Escape special regular expression characters in a given string.
    
      @method _escapeRegExpString
      @return String
     */
    _escapeRegExpString: function(str) {
      return str.replace(ESCAPE_REG_EXP, ESCAPE_REPLACEMENT);
    },

    /*
      @private
    
      Split a string using the regular expression in the `_delimiter_pattern`
      property. Add the results to a provided result array.
    
      @method _splitStringByDelimiter
      @param String str A string to process
      @param Array result An array to add the results to
      @return Array The provided result array
     */
    _splitStringByDelimiter: function(str, result) {
      var pattern, v, values, _i, _len;
      if (str == null) {
        str = '';
      }
      if (result == null) {
        result = Ember.A();
      }
      pattern = get(this, '_delimiter_pattern');
      values = str.split(pattern);
      result.clear();
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        v = values[_i];
        v = jQuery.trim(v);
        if ((v == null) || v === '') {
          continue;
        }
        result.addObject(v);
      }
      return result;
    },

    /*
      @private
    
      Prepares (trims) a string to be a tag.
    
      @method _prepareStringTag
      @param String value The string to capture
      @return {String|Boolean} Processed value or false
     */
    _prepareStringTag: function(value) {
      if (value == null) {
        value = '';
      }
      value = jQuery.trim(value);
      if (value === '' || this.contains(value)) {
        return false;
      }
      if (get(this, '_delimiter_pattern').test(value)) {
        this.capture(value);
        return false;
      }
      return value;
    },

    /*
      @private
    
      Validates an object for tag-worthiness.
    
      @method _prepareObjectTag
      @param Object value The object to capture
      @return {Object|Boolean} Validated object or false
     */
    _prepareObjectTag: function(value) {
      if (!(value && this._isValidTagValue(value))) {
        Ember.warn("Attempted to add an object without a value at " + get(this, 'contentPath'));
        return false;
      }
      if (this.contains(value)) {
        return false;
      } else {
        return value;
      }
    },

    /*
      @private
    
      Routes an array of tags back to addTags for proper processing.
    
      @method _prepareArrayTag
      @param Array value The array to capture
      @return Boolean
     */
    _prepareArrayTag: function(value) {
      this.addTags(value);
      return false;
    },

    /*
      @private
    
      Checks a tag to see if it contains a defined value at the `contentPath`.
    
      @method _isValidTagValue
      @param Mixed value The value to check
      @return Boolean
     */
    _isValidTagValue: function(value) {
      var contentPath;
      if (!value) {
        return false;
      }
      contentPath = get(this, 'contentPath');
      return !!(get(value, contentPath));
    },

    /* CONTENT ARRAY MANAGEMENT */

    /*
      Hook for responding to the content array being replaced with a new
      array instance. Override to add custom handling.
    
      @method contentWillChange
      @param {Object} self
     */
    contentWillChange: Ember.K,

    /*
      Hook for responding to the content array being replaced with a new
      array instance. Override to add custom handling.
    
      @method contentDidChange
      @param {Object} self
     */
    contentDidChange: function() {
      if (get(this, 'state') === 'inDOM') {
        return this._rerenderList();
      }
    },

    /*
      Hook for responding to impending updates to the content array. Override to
      add custom handling for array updates.
    
      @method contentArrayWillChange
      @param {Array} array The array instance being updated
      @param {Integer} idx The index where changes applied
      @param {Integer} removedCount
      @param {Integer} addedCount
     */
    contentArrayWillChange: function(array, idx, removedCount, addedCount) {
      return this;
    },

    /*
      Hook for responding to updates to the content array. Override to
      add custom handling for array updates.
    
      @method contentArrayDidChange
      @param {Array} array The array instance being updated
      @param {Integer} idx The index where changes applied
      @param {Integer} removedCount
      @param {Integer} addedCount
     */
    contentArrayDidChange: function(array, idx, removedCount, addedCount) {
      this._updateChildViews();
      if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {
        return this;
      }
      this.incrementProperty('cursor', (addedCount || 0) - (removedCount || 0));
      if (this.isStringContent()) {
        this.updateValue();
      }
      return this;
    },

    /*
      @private
    
      Content array change handler.
    
      @method _contentWillChange
     */
    _contentWillChange: Ember.beforeObserver(function() {
      var content, len;
      content = get(this, 'content');
      len = content ? get(content, 'length') : 0;
      this.contentArrayWillChange(this, 0, len, void 0);
      this.contentWillChange(this);
      return this._teardownContent(content);
    }, 'content'),

    /*
      @private
    
      Content array change handler.
    
      @method _contentDidChange
     */
    _contentDidChange: Ember.observer(function() {
      var content, len;
      content = get(this, 'content');
      len = content ? get(content, 'length') : 0;
      this._setupContent(content);
      this.contentDidChange(this);
      return this.contentArrayDidChange(this, 0, void 0, len);
    }, 'content'),

    /*
      @private
    
      Remove change observing on content array.
    
      @method _teardownContent
     */
    _teardownContent: function() {
      var content;
      this._clearContent();
      content = get(this, 'content');
      if (content) {
        return content.removeArrayObserver(this, {
          willChange: 'contentArrayWillChange',
          didChange: 'contentArrayDidChange'
        });
      }
    },

    /*
      @private
    
      Begin change observing on content array.
    
      @method _setupContent
     */
    _setupContent: function() {
      var content;
      content = get(this, 'content');
      if (content) {
        return content.addArrayObserver(this, {
          willChange: 'contentArrayWillChange',
          didChange: 'contentArrayDidChange'
        });
      }
    },

    /*
      @private
    
      Empty the content array.
    
      @method _clearContent
     */
    _clearContent: function() {
      var content;
      content = get(this, 'content');
      if (content) {
        return content.clear();
      }
    }
  });


  /*
    `Emberella.TagItemView` is designed to be a drop-in tag item listing view for
    an `Emberella.TagsInput` container view. Each instance of
    `Emberella.TagItemView` inherits its template and the majority of its
    properties from its parent view. Each tag item also responds to a variety of
    keyboard events to provide familiar interactions to users.
  
    @class TagItemView
    @namespace Emberella
    @extends Ember.View
    @uses Ember.StyleBindingsMixin
    @uses Emberella.FocusableMixin
    @uses Emberella.KeyboardControlMixin
   */

  Emberella.TagItemView = Ember.View.extend(Ember.StyleBindingsMixin, Emberella.FocusableMixin, Emberella.KeyboardControlMixin, Emberella.MembershipMixin, {
    inherit: ['template', 'contentPath', 'deleteCharacter', 'deleteTitle', 'stylist', 'disabled'],
    actions: {
      removeSelf: function() {
        return this.removeSelf.apply(this, arguments);
      }
    },

    /*
      The type of element to render this view into. By default, tag items will
      appear in `<span/>` elements.
    
      @property tagName
      @type String
      @default 'span'
     */
    tagName: 'span',

    /*
      Add the 'emberella-tag-item' class to each tag item. Use this class to
      style your tags.
    
      @property classNames
      @type Array
      @default ['emberella-tag-item']
     */
    classNames: ['emberella-tag-item'],

    /*
      Add the computed `stylistClasses` property as additional classes for
      this tag listing.
    
      @property classNameBindings
      @type Array
      @default ['stylistClasses']
     */
    classNameBindings: ['stylistClasses'],

    /*
      Toggle the `display` style based on the property of the same name.
    
      @property styleBindings
      @type Array
      @default ['display']
     */
    styleBindings: ['display'],

    /*
      Prevent focus with TAB key.
    
      @property tabindex
      @type Integer
      @default -1
     */
    tabindex: -1,

    /*
      The content to display in the listing.
    
      @property content
      @type Mixed
      @default null
     */
    content: null,

    /*
      The position of this listing in the parent view's content.
    
      @property index
      @type Integer
      @default null
     */
    index: null,

    /*
      Computes the string to display in the DOM based on the listing's content
      and contentPath.
    
      @property displayContent
      @type String
      @readOnly
     */
    displayContent: Ember.computed(function() {
      var content, contentPath, _ref;
      if ((content = get(this, 'content')) == null) {
        return '';
      }
      contentPath = get(this, 'contentPath');
      return (_ref = get(content, contentPath)) != null ? _ref : content;
    }).property('content', 'contentPath').readOnly(),

    /*
      Iterates over the stylist object (if one is set) and assembles a
      space-delimited string of classes to add to this listing view.
    
      @property stylistClasses
      @type String
     */
    stylistClasses: Ember.computed(function() {
      var content, fn, key, ret, stylist;
      if (!((content = get(this, 'content')) && (stylist = get(this, 'stylist')) && typeOf(stylist) === 'object')) {
        return '';
      }
      ret = Ember.A();
      for (key in stylist) {
        if (!__hasProp.call(stylist, key)) continue;
        fn = stylist[key];
        if (typeOf(fn) !== 'function') {
          continue;
        }
        if (fn.call(this, content)) {
          ret.pushObject(key);
        }
      }
      return ret.join(' ');
    }).property('stylist', 'content'),

    /*
      Set display style to 'none' when content is empty.
    
      @property display
      @type String
     */
    display: Ember.computed(function() {
      if (Ember.isEmpty(get(this, 'content'))) {
        return 'none';
      } else {
        return void 0;
      }
    }).property('content'),

    /*
      Remove this listing's content from the parent view's content array.
    
      Subsequently, this listing will be removed from the DOM or recycled with
      new content.
    
      @method removeSelf
      @chainable
     */
    removeSelf: function() {
      return this.dispatch('removeTag', get(this, 'content'));
    },

    /*
      Respond to the backspace key.
    
      @event backspacePressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    backspacePressed: function(e, alt, ctrl, meta, shift) {
      if (alt || ctrl || meta || shift) {
        return;
      }
      this.dispatch('cursorAfter');
      return this.removeSelf();
    },

    /*
      Respond to the ("forward") delete key.
    
      @event deletePressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    deletePressed: Ember.aliasMethod('backspacePressed'),

    /*
      Respond to the right arrow key.
    
      @event rightArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    rightArrowPressed: function(e, alt, ctrl, meta, shift) {
      if (alt || ctrl || meta) {
        return;
      }
      return this.dispatch(shift ? 'focusAfter' : 'cursorAfter');
    },

    /*
      Respond to the left arrow key.
    
      @event leftArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    leftArrowPressed: function(e, alt, ctrl, meta, shift) {
      if (alt || ctrl || meta) {
        return;
      }
      if (shift) {
        return this.dispatch('focusBefore');
      } else {
        return this.dispatch('moveCursor', this, 0);
      }
    },

    /*
      Respond to the up arrow key.
    
      @event upArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    upArrowPressed: function(e, alt, ctrl, meta, shift) {
      return this.dispatch('upArrowPressed', e, alt, ctrl, meta, shift);
    },

    /*
      Respond to the down arrow key.
    
      @event downArrowPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    downArrowPressed: function(e, alt, ctrl, meta, shift) {
      return this.dispatch('downArrowPressed', e, alt, ctrl, meta, shift);
    },

    /*
      Respond to the enter/return key.
    
      @event enterPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    enterPressed: Ember.aliasMethod('rightArrowPressed'),

    /*
      Respond to the TAB key.
    
      @event tabPressed
      @param Event e The jQuery keyDown event
      @param Boolean alt Alt/option key is pressed
      @param Boolean ctrl Control key is pressed
      @param Boolean meta Meta/Command key is pressed
      @param Boolean shift Shift key is pressed
      @chainable
     */
    tabPressed: Ember.aliasMethod('rightArrowPressed'),

    /*
      Stop propagation of key down events.
    
      @event keyDown
     */
    keyDown: function(e) {
      e.stopPropagation();
      return this._super.apply(this, arguments);
    },

    /*
      Handle key press events.
    
      @event keyPress
     */
    keyPress: function(e) {
      this._super(e);
      if (e.isDefaultPrevented()) {
        return;
      }
      return this.backspacePressed(e, false, e.ctrlKey, e.metaKey, false);
    }
  });


  /*
    `Emberella.TagItemInput` is a flexible text field that moves to the cursor
    position of its parent view. An extension of `Emberella.FlexibleTextField`,
    this input is designed to squeeze between tag listings and allow the user to
    enter text (and create tags) at any position in the tag array.
  
    @class TagItemInput
    @namespace Emberella
    @extends Emberella.FlexibleTextField
    @uses Emberella.FocusableMixin
    @uses Emberella.KeyboardControlMixin
   */

  Emberella.TagItemInput = Emberella.FlexibleTextField.extend(Emberella.FocusableMixin, Emberella.KeyboardControlMixin, Emberella.MembershipMixin, {
    inherit: ['disabled'],
    isTagItemInput: true,

    /*
      Displays placeholder text until this input or the parent view have a value
      to display.
    
      @property placeholder
      @type String
     */
    placeholder: Ember.computed(function() {
      if (get(this, 'disabled') || get(this, 'parentView.content.length')) {
        return '';
      } else {
        return get(this, 'parentView.placeholder');
      }
    }).property('parentView.placeholder', 'parentView.content.length'),

    /*
      Handle paste events.
    
      @method paste
     */
    paste: function(e) {
      return this._didPaste = true;
    }
  });

}).call(this);
